---
title: "trabajo1"
author: "Jonatan Sanchez, Carlos Calle, Natalia Remolina & Juan Camilo Valencia"
date: "2025-04-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

library(GA)

```{r}

```

# OptimizaciÃ³n numÃ©rica

## FunciÃ³n de Rastrigin

La funciÃ³n de Rastrigin se define como:

$$
f(\mathbf{x}) = A n + \sum_{i=1}^{n} \left[ x_i^2 - A \cos(2 \pi x_i) \right]
$$

Donde, $\mathbf{x} = (x_1, x_2, \ldots, x_n) \in \mathbb{R}^n$

```{r}
rastrigin <- function(x, A = 10) {
  n <- length(x)
  A * n + sum(x^2 - A * cos(2 * pi * x))
}
```

### Grafico de la funciÃ³n de Rastrigin (1D)

```{r}
# RASTRIGIN 1-D
# Este bloque dibuja la funciÃ³n Rastrigin en una sola variable
# y marca con puntos rojos los mÃ­nimos locales situados
# en cada nÃºmero entero entre âˆ’5 y +5.

# 1) Convertimos la funciÃ³n â€˜rastrigin()â€™ a una versiÃ³n que
#    acepte un vector de x y devuelva un vector de resultados.
#    Vectorize() hace eso automÃ¡ticamente.
rastrigin_1d <- Vectorize(function(x) rastrigin(x))

# 2) Dibujamos la curva:
#    â€¢ from / to  â†’ rango del eje X
#    â€¢ n          â†’ nÃºmero de puntos que se calculan
#    â€¢ xlab, ylab â†’ etiquetas de los ejes
#    â€¢ main       â†’ tÃ­tulo del grÃ¡fico
curve(
  rastrigin_1d(x),          # la funciÃ³n a pintar
  from = -5.12, to = 5.12,  # lÃ­mites de X
  n    = 1000,              # resoluciÃ³n del trazo
  xlab = "x",               # texto en eje X
  ylab = "f(x)",            # texto en eje Y
  main = "Rastrigin 1D â€” campo de pozos periÃ³dicos"
)

# 3) AÃ±adimos PUNTOS ROJOS en cada entero (â€¦ âˆ’5, âˆ’4, â€¦, 4, 5)
#    para resaltar los mÃ­nimos locales de la funciÃ³n.
points(
  -5:5,                     # posiciones X de los puntos
  rastrigin_1d(-5:5),       # alturas Y = f(x) en esas X
  pch = 19,                 # tipo de sÃ­mbolo (19 = punto sÃ³lido)
  col = "red"               # color de los puntos
)

```

#### AnÃ¡lisis del grÃ¡fico â€œRastrigin 1-D â€” campo de pozos periÃ³dicosâ€

+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Elemento visual                             | ObservaciÃ³n                                                   | InterpretaciÃ³n                                                                                                                                                                                         |
+=============================================+===============================================================+========================================================================================================================================================================================================+
| **LÃ­nea negra dentada**                     | Ondas regulares de amplitud creciente al alejarse del centro. | Resultado de la combinaciÃ³n *cuadrado* (x2x\^{2}x2) + *coseno* (cosâ¡2Ï€x\cos 2\\pi xcos2Ï€x). El tÃ©rmino cuadrÃ¡tico empuja hacia arriba (crece como cuenco), el coseno introduce la ondulaciÃ³n periÃ³dica. |
+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Puntos rojos (11)**                       | Un punto rojo en cada entero desde âˆ’5 hasta 5.                | Representan los **mÃ­nimos locales**: los pozos donde un optimizador basado solo en gradientes podrÃ­a quedar atrapado.                                                                                  |
+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Valle mÃ¡s profundo en** x=0x = 0x=0       | Punto rojo mÃ¡s bajo (f(x)=0).                                 | **MÃ­nimo global** de la funciÃ³n.                                                                                                                                                                       |
+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SimetrÃ­a izquierda-derecha**              | La curva es espejo respecto a x=0.                            | Tanto x2 como cosâ¡(2Ï€x) son funciones pares â†’ la funciÃ³n es simÃ©trica.                                                                                                                                  |
+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Incremento de altura hacia los extremos** | Las puntas laterales alcanzan f(x)â‰ˆ40f(x) .                   | Dominio del tÃ©rmino x2. Cuanto mÃ¡s lejos del centro, mÃ¡s alto el coste.                                                                                                                                |
+---------------------------------------------+---------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

1.  **Alta multimodalidad**\
    Once pozos en un intervalo de solo 10 unidades indican que la funciÃ³n estÃ¡ plagada de Ã³ptimos locales.

2.  **Periodocidad**\
    La distancia constante entre picos (â‰ˆ 1) viene del coseno cosâ¡(2Ï€x); cada ciclo completo genera un pozo.

### Grafico de la funciÃ³n de Rastrigin (2D)

```{r}

# RASTRIGIN 2-D 
# Objetivo: dibujar un â€œmapa de calorâ€ que muestre los pozos locales
# y el mÃ­nimo global de la funciÃ³n Rastrigin en dos variables.


# 1. Crear la rejilla (grilla) de puntos 
#    â€¢ seq() genera 200 valores igualmente espaciados
#    â€¢ El rango va de âˆ’5.12 a +5.12 (dominio tÃ­pico de prueba)
x <- y <- seq(-5.12, 5.12, length.out = 200)

# 2. Calcular f(x1,x2) para cada punto de la rejilla 
#    â€¢ outer() combina todos los x con todos los y
#    â€¢ Vectorize() convierte la llamada a rastrigin() en â€œapta para matrizâ€
z <- outer(
  x, y,
  Vectorize(function(a, b) rastrigin(c(a, b)))  # a = x1, b = x2
)

# 3. Dibujar el contorno coloreado 
filled.contour(
  x, y, z,
  color.palette = terrain.colors,  # paleta â€œrelieveâ€ (verde-marrÃ³n)
  nlevels       = 30,              # nÃºmero de franjas de color
  plot.title = title(
    main = "Rastrigin 2-D â€” campo de minas",   # tÃ­tulo grande
    xlab = "x1",                               # etiqueta eje X
    ylab = "x2"                                # etiqueta eje Y
  ),

  # --- plot.axes: todo lo que aÃ±adas aquÃ­ se superpone al grÃ¡fico ---
  plot.axes = {
    axis(1); axis(2)                                # muestra los ejes
    abline(h = -5:5, v = -5:5,                      # rejilla entera
           col = "grey90", lty = 3)                 # lÃ­neas gris claro
    points(0, 0,                                    # coord. (0,0)
           pch = 8,    # sÃ­mbolo estrella
           col = "black",
           cex = 1.5)                              # tamaÃ±o 1.5Ã—
  }
)


```

#### AnÃ¡lisis del grÃ¡fico â€œRastrigin 2-D â€” campo de minasâ€

+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| # Elemento visual                           | # QuÃ© se observa                          | # QuÃ© significa                                                                                                 |
|                                             |                                           |                                                                                                                 |
| **Gradiente de color (barra a la derecha)** | Verde muy oscuro â†’ Valores cercanos a 0.\ | Indica la *altura* de la funciÃ³n f(x1,x2). Los colores claros son â€œcerrosâ€; los oscuros, â€œvallesâ€.              |
|                                             | Amarillo â†’ â‰ˆ 40.\                         |                                                                                                                 |
|                                             | Rosa-blanco â†’ â‰ˆ 80 (mÃ¡s alto).            |                                                                                                                 |
+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| **Estrella negra en (0, 0)**                | Ãšnico punto marcado en el centro.         | **MÃ­nimo global**: f(0,0)=0. Cualquier optimizador querrÃ¡ llegar aquÃ­.                                          |
+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| **Malla gris punteada**                     | LÃ­neas cada unidad en ambos ejes.         | Subraya que la funciÃ³n es **separable y periÃ³dica**: los mÃ­nimos locales se repiten exactamente en cada entero. |
+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+
| **Ã“valos verdes/amarillos repetidos**       | PatrÃ³n regular horizontal y vertical.     | Cada Ã³valo es un **pozo local**; la cuadrÃ­cula entera corresponde a la estructura cosâ¡(2Ï€xi) de Rastrigin.       |
+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+
|                                             |                                           |                                                                                                                 |
+---------------------------------------------+-------------------------------------------+-----------------------------------------------------------------------------------------------------------------+

1.  **Alta multimodalidad**\
    Hay decenas de valles; un descenso por gradiente tÃ­pico corre riesgo de quedar atrapado en cualquiera de ellos.

2.  **Separabilidad**\
    Las lÃ­neas punteadas muestran que los mÃ­nimos estÃ¡n exactamente en los cruces de enteros (x1,x2)âˆˆZ2. La funciÃ³n puede verse como la suma de dos copias 1-D independientes.

3.  **Incremento radial suave**\
    A medida que nos alejamos del centro, los colores se vuelven lentamente rosados

4.  **â€œCampo de minasâ€**\
    Optimizar aquÃ­ es como cruzar un terreno lleno de crÃ¡teres: cada cuadrÃ­cula contiene un pozo que puede atrapar al algoritmo.

## Grafico de la funciÃ³n de Rastrigin (3D)

```{r}
# RASTRIGIN 2-D  â€“  Superficie 3-D (versiÃ³n mejorada)
# ----------------------------------------------------------
# Este bloque pinta la â€œmontaÃ±a rusaâ€ de la funciÃ³n Rastrigin
# en dos variables.


persp(
  x, y, z,                    # rejilla X, Y y matriz Z = f(x1,x2)

  # --- Ãngulo de la cÃ¡mara --------------------------------
  theta  = 45,                # giro horizontal (0Âº = de frente)
  phi    = 30,                # elevaciÃ³n de la cÃ¡mara (0Âº = plano)

  # --- Escala y tamaÃ±o ------------------------------------
  expand = 0.6,               # â€œachataâ€ la altura poco mas de la mitad
                              
  # --- Colores y sombras ----------------------------------
  col    = "springgreen",     # color bÃ¡sico de la superficie
  shade  = 0.2,               # 0 = sin sombra ; 1 = oscurecer mucho
  ltheta = 120,               # Ã¡ngulo de la luz (120Âº = diagonal)

  # --- Detalles de los ejes -------------------------------
  ticktype = "detailed",      # ticks completos con nÃºmeros

  # --- Etiquetas de los ejes ------------------------------
  xlab = "x1",                # etiqueta eje X
  ylab = "x2",                # etiqueta eje Y
  zlab = "f(x)",              # etiqueta eje Z (altura)

  # --- TÃ­tulo del grÃ¡fico ---------------------------------
  main = "Rastrigin 2D â€” superficie 3D "
)

```

#### Superficie 3-D de la funciÃ³n Rastrigin en dos dimensiones.

Se aprecia un cuenco global con un mosaico de mÃ­nimos locales periÃ³dicos.\

El mÃ­nimo global estÃ¡ en (0,0) y las crestas alcanzan valores de f(x)â‰ˆ80.

-   **Implicaciones para la optimizaciÃ³n**

```         
-   **Gradiente â€œtraicioneroâ€**\
    Desde un punto alto, el gradiente guÃ­a hacia el valle **mÃ¡s cercano, no el global**; por eso un descenso por gradiente sencillo suele frenarse en uno de esos crÃ¡teres perifÃ©ricos.

-   **Incremento radial suave + oscilaciÃ³n fina**\
    La combinaciÃ³n hace que los valles laterales sean relativamente profundos: un algoritmo necesita capacidad de *exploraciÃ³n* para saltar varias crestas y acercarse al centro.

<!-- -->

-   MÃ©todos **locales** (GD, Newton) requieren muchos reinicios o mejoras (momentum, annealing).

-    Estrategias **bioinspiradas** (PSO, hormigas) o **cuasi-Newton** (L-BFGS-B) suelen rendir mejor, porque pueden escapar de pozos.
```

## FunciÃ³n de Schwefel

$$
f(\mathbf{x}) = 418.9829 \cdot n - \sum_{i=1}^{n} x_i \sin\left(\sqrt{|x_i|}\right)
$$

Donde, $\mathbf{x} = (x_1, x_2, \ldots, x_n) \in \mathbb{R}^n$

```{r}
schwefel <- function(x) {
  n <- length(x)
  418.9829 * n - sum(x * sin(sqrt(abs(x))))
}
```

## Descenso del gradiente (GD)

### Gradiente

```{r}
grad_rastrigin <- function(x, A = 10) {
  2 * x + 2 * pi * A * sin(2 * pi * x)
}
```

### FunciÃ³n GD

```{r}
# FunciÃ³n GD simple con historial
gd_once <- function(x0, lr = 0.01, iters = 200) {
  x <- x0
  hist <- matrix(NA, nrow = iters, ncol = length(x0) + 1)  # guarda x1, x2, f(x)

  for (k in 1:iters) {
    g <- grad_rastrigin(x)       # gradiente
    x <- x - lr * g              # paso GD
    hist[k, ] <- c(x, rastrigin(x))  # guardar estado
  }

  colnames(hist) <- c(paste0("x", 1:length(x0)), "f")
  return(as.data.frame(hist))
}

```

### Rastringin

### ImplementaciÃ³n de GD en Rastrigin 1D

#### Trayectoria de GD puro sobre Rastringin (1D)

```{r}

# GRÃFICO 1-D CON GD_PURO  

# 1. Ejecutar el descenso por gradiente 
x0 <- 3                            # punto de partida
traj1d <- gd_once(x0, lr = 0.01, iters = 200)

# 2. AÃ±adir la columna de iteraciÃ³n  
traj1d$iter <- seq_len(nrow(traj1d)) - 1   # 0, 1, 2, â€¦

# 3. Graficar Rastrigin 1-D y la trayectoria
rastrigin_v <- Vectorize(rastrigin)

curve(rastrigin_v(x), from = -5.12, to = 5.12, n = 1000,
      xlab = "x", ylab = "f(x)",
      main = "Trayectoria de GD puro en Rastrigin 1-D")

# LÃ­nea azul con el camino del algoritmo
points(traj1d$x1, traj1d$f, type = "l",
       col = "dodgerblue", lwd = 2)

# Puntos de inicio (rojo) y final (negro)
points(x0, rastrigin(x0),                pch = 19, col = "red")   # inicio
points(tail(traj1d$x1, 1), tail(traj1d$f, 1),
       pch = 17, col = "black")                                   # fin


```

+-------------------+-----------------------------------------------------------------------------------------------------------------------------+
| # Color / SÃ­mbolo | # Significado correcto                                                                                                      |
|                   |                                                                                                                             |
| **â–² Negro**       | **Punto inicial** x0â‰ˆ2.9\mathbf{x}\_0 \approx 2.9x0â€‹â‰ˆ2.9. El descenso por gradiente parte aquÃ­, en la ladera alta del valle. |
+-------------------+-----------------------------------------------------------------------------------------------------------------------------+
| **â— Rojo**        | **Punto final**: mÃ­nimo local alcanzado tras 200 iteraciones, xâ‰ˆ2.8 con f(x)â‰ˆ14â€‰â£âˆ’â€‰â£15                                        |
+-------------------+-----------------------------------------------------------------------------------------------------------------------------+
| **Zona azul**     | Todos los pasos intermedios; muestra cÃ³mo GD oscila dentro del mismo valle hasta estabilizarse en el punto rojo.            |
+-------------------+-----------------------------------------------------------------------------------------------------------------------------+

#### AnÃ¡lisis

1.  **Descenso rÃ¡pido**\
    El algoritmo parte del punto **negro** (valor fâ‰ˆ27) y se desliza cuesta abajo siguiendo el gradiente.

2.  **Oscilaciones amortiguadas**\
    En azul se ve cÃ³mo va rebotando a ambos lados del eje del valle. Cada rebote es mÃ¡s pequeÃ±o porque el gradiente se reduce a medida que se acerca al fondo.

3.  **Convergencia local, fracaso global:**\
    El algoritmo se detiene en el **punto rojo**, el fondo del pozo local. AllÃ­ la pendiente es prÃ¡cticamente nula y se cumple el criterio de paro. **Queda atrapado** en el primer mÃ­nimo local encontrado.

4.  **Influencia del punto de partida**: cualquier inicio en el intervalo [2.5,3.5] producirÃ­a resultados parecidos; reiniciar desde zonas distintas sÃ³lo trasladarÃ­a el problema a otros pozos.

5.  **Distancia al Ã³ptimo global**\
    El Ã³ptimo global de Rastrigin (x=0,â€…â€Šf=0) queda fuera de la zona azul; GD nunca lo â€œvisitaâ€. Esto evidencia la limitaciÃ³n de los mÃ©todos locales en funciones multimodales.

6.  **Necesidad de estrategias complementarias**: para alcanzar el Ã³ptimo global en Rastrigin se requieren tÃ©cnicas que permitan â€œsaltarâ€ valles (momentum, tasa de aprendizaje adaptativa, meta-heurÃ­sticas globales).

### ImplementaciÃ³n de GD en Rastrigin 2D

#### Trayectoria de GD puro sobre Rastringin (2D)

```{r}
# 1) LibrerÃ­as para graficar -----------------------------------
library(ggplot2)
library(viridis)

# 2) Malla (superficie de referencia) --------------------------
x_vals <- y_vals <- seq(-5.12, 5.12, length.out = 200)
contour_df <- expand.grid(x1 = x_vals, x2 = y_vals)
contour_df$z <- mapply(
  function(a, b) rastrigin(c(a, b)),
  contour_df$x1, contour_df$x2
)

# 3) Ejecutar Gradient Descent puro ----------------------------
#    Â· sin argumentos â€œmax_iterâ€ ni â€œtolâ€ â†’ usamos â€˜itersâ€™
gd_res <- gd_once(c(3, 3), lr = 0.01, iters = 200)

# 4) Construir data frame con las columnas que ggplot necesita
traj_df <- data.frame(
  x1   = gd_res$x1,                 # posiciones en eje X
  x2   = gd_res$x2,                 # posiciones en eje Y
  f    = gd_res$f,                  # valor de la funciÃ³n
  iter = seq_len(nrow(gd_res)) - 1  # contador de iteraciones 0â€¦199
)
# 5) Definir los puntos de Inicio y Fin para la leyenda -------
puntos_df <- data.frame(
  x1   = c(traj_df$x1[1], tail(traj_df$x1, 1)),
  x2   = c(traj_df$x2[1], tail(traj_df$x2, 1)),
  tipo = factor(c("Fin", "Inicio"), levels = c("Fin", "Inicio"))
)

# 5) GrÃ¡fico estÃ¡tico ------------------------------------------------
ggplot() +
  # Fondo: mapa de calor f(x)
  geom_tile(data = contour_df,
            aes(x1, x2, fill = z)) +
  geom_contour(data = contour_df,
               aes(x1, x2, z = z),
               colour = "white", alpha = 0.25, bins = 25) +
  scale_fill_viridis_c(option = "D", name = expression(f(x))) +

  # Trayectoria
  geom_path(data = traj_df,
            aes(x1, x2),
            colour = "dodgerblue", linewidth = 1.3) +
  geom_point(data = traj_df[1, ],        # punto inicial
             aes(x1, x2),
             colour = "black", size = 3) +
  geom_point(data = tail(traj_df, 1),    # punto final
             aes(x1, x2),
             colour = "red", size = 3) +
  # Puntos de inicio y fin con leyenda automÃ¡tica
  geom_point(data = puntos_df,
             aes(x = x1, y = x2, colour = tipo, shape = tipo),
             size = 3) +
  scale_colour_manual(values = c("Inicio" = "black", "Fin" = "red"),
                      name   = "") +
  scale_shape_manual(values = c("Inicio" = 16,      # cÃ­rculo lleno
                                "Fin"    = 17),     # triÃ¡ngulo
                     name    = "") +

  # Detalles estÃ©ticos
  labs(title    = "Trayectoria de GD puro sobre Rastrigin 2D",
       subtitle = "â€¢  Rojo = mÃ­nimo local donde se atasca",
       x = expression(x[1]), y = expression(x[2])) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right",
        plot.title      = element_text(face = "bold"))


```

##### DescripciÃ³n del grÃ¡fico

-   

    +----------------------------------+------------------------------------------------------------------------------------+
    | Elemento                         | Significado                                                                        |
    +==================================+====================================================================================+
    | ğŸ”µ **Trayectoria azul**          | Secuencia de pasos que toma Gradient Descent desde el punto inicial.               |
    +----------------------------------+------------------------------------------------------------------------------------+
    | âš« **CÃ­rculo negro (Inicio)**    | PosiciÃ³n de partida (3,3) del algoritmo.                                           |
    +----------------------------------+------------------------------------------------------------------------------------+
    | ğŸ”º **TriÃ¡ngulo rojo (Fin)**      | MÃ­nimo local donde GD queda atrapado tras 200 iteraciones.                         |
    +----------------------------------+------------------------------------------------------------------------------------+
    | **Mapa de colores (f(x))**       | Valor de la funciÃ³n Rastrigin; violeta oscuro â‰ƒ 0 (valles), amarillo â‰ƒ 80 (picos). |
    +----------------------------------+------------------------------------------------------------------------------------+

##### AnÃ¡lisis del comportamiento del algoritmo

+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ObservaciÃ³n                                                            | InterpretaciÃ³n                                                                                                                                              |
+========================================================================+=============================================================================================================================================================+
| El recorrido es **muy corto** y se queda en la parte superior-derecha. | GD se vio atraÃ­do por el **valle local mÃ¡s prÃ³ximo** y no dispuso de mecanismos para â€œsaltarâ€ la siguiente cresta.                                          |
+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Valor final fâ‰ˆ17 frente al mÃ­nimo global f\*=0.                        | Confirma el **estancamiento prematuro** en un Ã³ptimo local.                                                                                                 |
+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Trayectoria casi rectilÃ­nea hacia un solo pozo.                        | El gradiente inicial apunta con fuerza a la depresiÃ³n mÃ¡s cercana; tras llegar al fondo la norma del gradiente se vuelve pequeÃ±a y el algoritmo se detiene. |
+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+

En funciones **altamente multimodales** como Rastrigin, el nÃºmero de valles hace muy improbable que GD, partiendo lejos del origen, alcance el **mÃ­nimo global**.

#### Animacion de la trayectoria de GD puro sobre Rastringin (2D)

```{r}

# GRÃFICO Y ANIMACIÃ“N 2-D DE UNA ÃšNICA TRAYECTORIA GD (sin   
# reinicios) SOBRE LA FUNCIÃ“N RASTRIGIN.                     



# 0) LibrerÃ­as y supuestos previos

library(ggplot2)
library(viridis)
library(gganimate)
library(dplyr)
library(gifski)



# 1) Datos de la superficie (contorno con leyenda f(x))
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
x_vals <- y_vals <- seq(-5.12, 5.12, length.out = 200)

contour_df <- expand.grid(x1 = x_vals, x2 = y_vals) %>%
  mutate(z = mapply(function(a, b) rastrigin(c(a, b)), x1, x2))


# 2) Una sola trayectoria con gd_once()
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
set.seed(42)                 # reproducibilidad
x0 <- c(3, 3)                # punto inicial elegido
gd_res <- gd_once(x0, lr = 0.01, iters = 50)

traj_df <- gd_res %>%
  mutate(iter = seq_len(n()) - 1)   # 0,1,2,â€¦ para animaciÃ³n


# 3) GrÃ¡fico estÃ¡tico
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ggplot() +
  geom_tile(data = contour_df,       # mapa de calor de f(x)
            aes(x1, x2, fill = z)) +
  geom_contour(data = contour_df,    # lÃ­neas de nivel
               aes(x1, x2, z = z),
               colour = "white", alpha = 0.3, bins = 30) +
  scale_fill_viridis_c(option = "D", name = expression(f(x))) +

  geom_path(data = traj_df,          # trayectoria azul
            aes(x1, x2),
            colour = "red", linewidth = 1.3) +
  geom_point(aes(x = x0[1], y = x0[2]),         # inicio (rojo)
             colour = "red",  size = 3) +
  geom_point(aes(x = tail(traj_df$x1,1),         # fin (negro)
                 y = tail(traj_df$x2,1)),
             colour = "black", size = 3) +

  labs(title    = "Trayectoria de GD puro sobre Rastrigin 2-D",
       subtitle = "egro = inicio   â€¢   Rojo = mÃ­nimo local alcanzado",
       x = expression(x[1]), y = expression(x[2])) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right",
        plot.title = element_text(face = "bold"))


# 4) AnimaciÃ³n 2-D de la misma trayectoria
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
p_anim <- ggplot() +
  geom_tile(data = contour_df,
            aes(x1, x2, fill = z)) +
  geom_contour(data = contour_df,
               aes(x1, x2, z = z),
               colour = "white", alpha = 0.3, bins = 30) +
  scale_fill_viridis_c(name = expression(f(x)), option = "D") +

  geom_path(data = traj_df,
            aes(x1, x2),
            colour = "red", linewidth = 1.3) +
  geom_point(data = traj_df,
             aes(x1, x2),
             colour = "black", size = 2) +

  labs(title    = "AnimaciÃ³n: trayectoria de GD puro (Rastrigin 2-D)",
       subtitle = "IteraciÃ³n: {frame_along}",
       x = expression(x[1]), y = expression(x[2])) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "right",
        plot.title = element_text(face = "bold")) +

  transition_reveal(along = iter) +
  ease_aes("linear")

animate(p_anim,
        nframes  = max(traj_df$iter) + 1,
        fps      = 15,
        width    = 700,
        height   = 500,
        units    = "px",
        renderer = gifski_renderer())


```

![](images/clipboard-1677513745.gif)

##### DinÃ¡mica observada

1.  **Inicio en un pico elevado**\
    Al â€œplayâ€, el punto negro parte en una zona amarilla (valor alto de fff), indicando un punto inicial lejos del mÃ­nimo.

2.  **Descenso pronunciado**\
    En las primeras iteraciones, el punto negro se desplaza rÃ¡pidamente hacia regiones mÃ¡s oscuras (valores de f decrecientes), cayendo dentro de un pozo local.

3.  **EstabilizaciÃ³n**\
    Una vez dentro del valle, la trayectoria azul rodea el fondo con pequeÃ±os vaivenes, reflejando zig-zags de GD puro en un entorno multimodal.

4.  **Sin escape del mÃ­nimo local**\
    A pesar de varias decenas de iteraciones, el punto nunca atraviesa la cresta que llevarÃ­a al valle central

### ImplementaciÃ³n de GD en Rastrigin 3D

#### Animacion de la trayectoria de GD puro sobre Rastringin (3D)

```{r}
library(plotly)
library(htmlwidgets)

# â€” 1) Superficie de Rastrigin â€”
x_vals  <- y_vals <- seq(-5.12, 5.12, length.out = 50)
z_matrix <- outer(x_vals, y_vals,
                  Vectorize(function(a,b) rastrigin(c(a,b))))

# â€” 2) EjecuciÃ³n de GD desde (3,3) â€”
set.seed(42)
res   <- gd_once(c(3, 3), lr = 0.01, iters = 50)
traj  <- as.matrix(res[, c("x1","x2")])    # n Ã— 2
fvals <- res$f                              # longitud n
iters <- seq_len(nrow(res)) - 1             # 0:(n-1)

# â€” 3) Ã“ptimo local â€”
opt_idx   <- which.min(fvals)
opt_point <- traj[opt_idx, ]
opt_val   <- fvals[opt_idx]

# â€” 4) ConstrucciÃ³n de frames CORREGIDA â€”
frames <- lapply(seq_along(iters), function(i) {
  list(
    data = list(
      NULL,  # trace 0: superficie (estÃ¡tico)
      # trace 1: lÃ­nea hasta iter i
      list(
        x    = traj[1:i,1],
        y    = traj[1:i,2],
        z    = fvals[1:i],
        type = "scatter3d", mode = "lines",
        line = list(color=0:(i-1), colorscale="Rainbow",
                    cmin=0, cmax=max(iters), width=6)
      ),
      # trace 2: punto mÃ³vil en iter i
      list(
        x      = traj[i,1],
        y      = traj[i,2],
        z      = fvals[i],
        type   = "scatter3d", mode = "markers",
        marker = list(size=6, color="black")
      ),
      NULL   # trace 3: Ã³ptimo (estÃ¡tico)
    ),
    name   = as.character(iters[i]),
    traces = c(1,2)  # animamos sÃ³lo lÃ­nea y punto
  )
})


# â€” 5) Figura inicial con 4 traces â€”
fig <- plot_ly() %>%
  # trace 0: superficie
  add_surface(
    x = ~x_vals, y = ~y_vals, z = ~z_matrix,
    colorscale = "Viridis", opacity = 0.2, showscale = FALSE
  ) %>%
  # trace 1: lÃ­nea (iter 0)
  add_trace(
    x    = traj[1,1], y = traj[1,2], z = fvals[1],
    type = "scatter3d", mode = "lines",
    line = list(color=0, colorscale="Rainbow",
                cmin=0, cmax=max(iters), width=6),
    name = "Trayectoria"
  ) %>%
  # trace 2: punto inicial
  add_trace(
    x      = traj[1,1], y = traj[1,2], z = fvals[1],
    type   = "scatter3d", mode = "markers",
    marker = list(size=6, color="black"),
    name   = "Punto actual"
  ) %>%
  # trace 3: Ã³ptimo encontrado
  add_trace(
    x      = opt_point[1], y = opt_point[2], z = opt_val,
    type   = "scatter3d", mode = "markers",
    marker = list(size=10, symbol="diamond", color="yellow"),
    name   = "Ã“ptimo encontrado"
  ) %>%
  layout(
    title = paste0("GD en Rastrigin 3D â€” IteraciÃ³n 0 â€” f = ", round(fvals[1],4)),
    scene = list(
      xaxis = list(title = "x1", range = c(-5.12,5.12)),
      yaxis = list(title = "x2", range = c(-5.12,5.12)),
      zaxis = list(title = "f(x)"),
      camera = list(
        eye = list(x=0.05, y=1.50, z=0.30),
        center = list(x=0,y=0,z=0),
        up     = list(x=0,y=0,z=1)
      )
    ),
    sliders = list(
      list(
        active = 0, pad = list(t=50),
        currentvalue = list(prefix="IteraciÃ³n: "),
        steps = lapply(seq_along(iters), function(i) {
          list(
            method = "animate",
            args   = list(list(as.character(iters[i])),
                          list(mode="immediate",
                               frame=list(duration=100, redraw=TRUE))),
            label  = as.character(iters[i])
          )
        })
      )
    ),
    updatemenus = list(
      list(
        type="buttons", showactive=FALSE,
        x=1, xanchor="right", y=0, yanchor="bottom",
        buttons=list(
          list(label="â–¶ Play", method="animate",
               args=list(NULL, list(frame=list(duration=100,redraw=TRUE),
                                     mode="immediate"))),
          list(label="â¸ Pause", method="animate",
               args=list(list(NULL), list(frame=list(duration=0,redraw=FALSE),
                                         mode="immediate")))
        )
      )
    )
  )

# â€” 6) Inyecta frames y habilita autoplay â€”
fig$x$frames <- frames
fig <- fig %>% onRender("
  function(el,x){
    el.on('plotly_buttonclicked',function(e){
      if(e.button && e.button.label==='â–¶ Play'){
        Plotly.animate(el,null,{frame:{duration:100,redraw:true},mode:'immediate'});
      }
    });
  }
")

# â€” 7) Guarda y muestra â€”
htmlwidgets::saveWidget(fig,
  "rastrigin_gd_3d_zoom_maximo_correcto.html",
  selfcontained = TRUE)
fig

```

| Elemento | Significado |
|----------|-------------|

+--------------------------------------+-----------------------------------------------------------------------------------------------------------+
| **Superficie translÃºcida (Viridis)** | Muestra el paisaje completo de la funciÃ³n Rastrigin: valles profundos (violeta) y picos altos (amarillo). |
+--------------------------------------+-----------------------------------------------------------------------------------------------------------+

+-----------------------------------------+---------------------------------------------------------------------------------------+
| ğŸŸ  **LÃ­nea multicolor (â€œTrayectoriaâ€)** | Cada tonalidad marca un paso de GD: del azul al naranja conforme avanza la iteraciÃ³n. |
+-----------------------------------------+---------------------------------------------------------------------------------------+

+-------------------------------------+----------------------------------------------------+
| âš« **Punto negro (â€œPunto actualâ€)** | Indica la posiciÃ³n de GD en la iteraciÃ³n mostrada. |
+-------------------------------------+----------------------------------------------------+

+---------------------------------------------+-----------------------------------------------------------+
| **Diamante amarillo (â€œÃ“ptimo encontradoâ€)** | SeÃ±ala el mÃ­nimo local donde el algoritmo quedÃ³ atrapado. |
+---------------------------------------------+-----------------------------------------------------------+

+-----------------------------------------------------------------------------------------------------------------+
| â–¶ï¸â¸ï¸ **Controles Play/Pause + slider** \| Permiten navegar interactivamente por las iteraciones. \| \| \| \| \| |
+-----------------------------------------------------------------------------------------------------------------+

##### Comportamiento de GD en 3D

1.  **Descenso inicial:**\
    Desde el punto (3â€Š,â€Š3â€Š), GD baja rÃ¡pidamente por la â€œparedâ€ del valle, capturado por el gradiente pronunciado.

2.  **Ingreso en un crÃ¡ter local:**\
    Tras unas pocas iteraciones, la trayectoria desciende al fondo de un pozo lateral, lejos del centro (0,0).

3.  **Estancamiento y micro-oscillaciones:**\
    Dentro de ese crÃ¡ter, GD gira en pequeÃ±os zig-zags alrededor de un mÃ­nimo que no es el global.

4.  **No alcanza el mÃ­nimo global:**\
    El diamante amarillo permanece alejado del valle central de la superficie, confirmando la captura en un mÃ­nimo local.

## Algoritmos evolutivos

### Rastrigin

#### Dos dimensiones

```{r}
set.seed(420)  # Semilla

GA_rastrigin_2d <- ga(
  type = "real-valued",
  fitness = function(x) -rastrigin(x),  # GA maximiza, por eso usamos el negativo
  lower = c(-5.12, -5.12),              # LÃ­mites inferiores
  upper = c(5.12, 5.12),                # LÃ­mites superiores
  popSize = 50,                         # TamaÃ±o de la poblaciÃ³n
  maxiter = 100,                        # NÃºmero mÃ¡ximo de iteraciones
  run = 50                              # Criterio de parada si no mejora
)

# Mostrar resultados
summary(GA_rastrigin_2d)

```

#### Tres dimensiones

```{r}
set.seed(420)  # Semilla

GA_rastrigin_3d <- ga(
  type = "real-valued",
  fitness = function(x) -rastrigin(x),  # GA maximiza, por eso usamos el negativo
  lower = c(-5.12, -5.12, -5.12),       # LÃ­mites inferiores
  upper = c(5.12, 5.12, 5.12),          # LÃ­mites superiores
  popSize = 50,                         # TamaÃ±o de la poblaciÃ³n
  maxiter = 100,                        # NÃºmero mÃ¡ximo de iteraciones
  run = 50                              # Criterio de parada si no mejora
)

# Mostrar resultados
summary(GA_rastrigin_3d)
```

## OptimizaciÃ³n de partÃ­culas

```{r}
pso_rastrigin_2d <- psoptim(
  par = c(NA, NA),                   # InicializaciÃ³n (puede ser aleatoria)
  fn = rastrigin,                    # FunciÃ³n a minimizar
  lower = c(-5.12, -5.12),           # LÃ­mites inferiores
  upper = c(5.12, 5.12),             # LÃ­mites superiores
  control = list(
    maxit = 200,                     # NÃºmero de iteraciones
    s = 40,                          # TamaÃ±o del enjambre (partÃ­culas)
    trace = 1                        # Mostrar progreso
  )
)
```

```{r}
pso_rastrigin_2d <- psoptim(
  par = c(NA, NA),                   # InicializaciÃ³n (puede ser aleatoria)
  fn = rastrigin,                    # FunciÃ³n a minimizar
  lower = c(-5.12, -5.12, -5.12),    # LÃ­mites inferiores
  upper = c(5.12, 5.12, 5.12),       # LÃ­mites superiores
  control = list(
    maxit = 200,                     # NÃºmero de iteraciones
    s = 40,                          # TamaÃ±o del enjambre (partÃ­culas)
    trace = 1                        # Mostrar progreso
  )
)
```

## EvoluciÃ³n diferencial

$CT_{ij} = PrecioPeajes_{ij} + Distancia_{ij}(km) * PrecioGasolina/km + Salario(Horas) * Tiempo_{ij}(Horas)$

```{r}
matriz_distancia <- read.csv("matriz_distancia.csv", row.names = 1)
matriz_tiempos <- read.csv("matriz_tiempos.csv", row.names = 1)
matriz_peajes <- read.csv("matriz_peajes.csv", row.names = 1)
```

```{r}
matriz_costo_gasolina <-  191*matriz_distancia
matriz_costo_salario <- 5416*matriz_tiempos

```

```{r}
matriz_costo_total <- matriz_peajes + matriz_costo_gasolina + matriz_costo_salario
matriz_costo_total <- as.matrix(matriz_costo_total)

```

```{r}
# Fijar semilla para reproducibilidad
set.seed(42)

# DefiniciÃ³n de parÃ¡metros
cities_count <- 13              # NÃºmero total de ciudades
eroso_influence <- 1            # Influencia de la feromona (antes gamma)
visibility_influence <- 2       # Influencia de la visibilidad (antes beta)
evap_rate <- 0.5               # Tasa de evaporaciÃ³n de feromonas
pheromone_strength <- 100       # Constante para depÃ³sito de feromonas
ants_count <- cities_count      # Una hormiga por estado
cities_names <- as.list(rownames(matriz_costo_total))

# Datos de entrada: matriz_costo_total (cities_count x cities_count) y state_names (vector de nombres)

# InicializaciÃ³n de matrices
tau_matrix <- matrix(1, nrow = cities_count, ncol = cities_count)  # Feromonas
eta_matrix <- 1 / matriz_costo_total                               # Visibilidad
eta_matrix[!is.finite(eta_matrix)] <- 0                             # Evitar Inf/NaN

# Variables para la mejor soluciÃ³n
best_path <- integer(0)
best_path_cost <- Inf

# Bucle principal: 100 iteraciones
for (iter_idx in seq_len(100)) {
  all_paths <- vector("list", ants_count)
  all_costs <- numeric(ants_count)

  for (ant_idx in seq_len(ants_count)) {
    current_node <- sample(seq_len(cities_count), 1)
    visited_nodes <- current_node
    path_cost <- 0

    # ConstrucciÃ³n de la ruta
    for (step_idx in seq_len(cities_count - 1)) {
      candidates <- setdiff(seq_len(cities_count), visited_nodes)
      trans_probs <- (
        tau_matrix[current_node, candidates]^eroso_influence *
        eta_matrix[current_node, candidates]^visibility_influence
      )
      if (all(trans_probs == 0)) trans_probs <- rep(1, length(candidates))
      if (length(candidates) == 1) {
        next_node <- candidates
        } else {
          next_node <- sample(candidates, 1, prob = trans_probs)
          }

      path_cost <- path_cost + matriz_costo_total[current_node, next_node]
      current_node <- next_node
      visited_nodes <- c(visited_nodes, current_node)
    }

    # Regreso al inicio
    dir_cost <- matriz_costo_total[current_node, visited_nodes[1]]
    path_cost <- path_cost + dir_cost

    all_paths[[ant_idx]] <- visited_nodes
    all_costs[ant_idx] <- path_cost

    # Actualizar mejor ruta
    if (path_cost < best_path_cost) {
      best_path_cost <- path_cost
      best_path <- visited_nodes
    }
  }

  # EvaporaciÃ³n de feromonas
  tau_matrix <- tau_matrix * (1 - evap_rate)

  # DepÃ³sito de feromonas
  for (i in seq_along(all_paths)) {
    path_nodes <- all_paths[[i]]
    cost_val <- all_costs[i]
    for (j in seq_len(length(path_nodes) - 1)) {
      tau_matrix[path_nodes[j], path_nodes[j+1]] <-
        tau_matrix[path_nodes[j], path_nodes[j+1]] + pheromone_strength / cost_val
    }
    # Feromona por retorno al inicio
    tau_matrix[path_nodes[length(path_nodes)], path_nodes[1]] <-
      tau_matrix[path_nodes[length(path_nodes)], path_nodes[1]] + pheromone_strength / cost_val
  }
}

# Convertir mejor ruta a nombres y agregar retorno al inicio
best_path_names <- cities_names[best_path]
best_path_names <- c(best_path_names, best_path_names[1])

# ImpresiÃ³n de resultados
cat("\nMejor ruta encontrada:\n")
cat(paste(best_path_names, collapse = " â†’ "), "\n")

cat("\nDetalle de costos por tramo:\n")
cat(sprintf("%-30s %-30s %10s\n", "Origen", "Destino", "Costo"))
cat(strrep("-", 70), "\n")

total_cost <- 0
for (idx in seq_along(best_path)) {
  origin <- best_path[idx]
  dest <- if (idx == length(best_path)) best_path[1] else best_path[idx+1]
  seg_cost <- matriz_costo_total[origin, dest]
  total_cost <- total_cost + seg_cost
  cat(sprintf("%-30s %-30s $%9.2f\n",
              cities_names[origin], cities_names[dest], seg_cost))
}

cat("\nEstadÃ­sticas:\n")
cat(sprintf("Ciudades (incluye retorno): %d\n", length(best_path_names)))
cat(sprintf("Costo total: $%0.2f\n", total_cost))
cat(sprintf("Costo promedio por tramo: $%0.2f\n", total_cost / length(best_path)))

```

```{r}
# Data.frame de ciudades con coordenadas
coords_df <- data.frame(
  city = c("BogotÃ¡", "MedellÃ­n", "Cali", "Barranquilla", "Cartagena",
           "Bucaramanga", "CÃºcuta", "Pereira", "Manizales", "IbaguÃ©",
           "Santa Marta", "Villavicencio", "Neiva"),
  lon  = c(-74.0721, -75.5812, -76.5320, -74.7813, -75.4794,
           -73.1227, -72.4965, -75.6961, -75.5174, -75.2322,
           -74.1990, -73.6260, -75.2803),
  lat  = c(4.7110,   6.2442,   3.4516,   10.9685,  10.3910,
           7.1193,   7.8891,   4.8133,   5.0672,   4.4389,
           11.2408,  4.1420,   2.9273),
  stringsAsFactors = FALSE
)

# Para comprobar
print(coords_df)

```

```{r}
library(osrm)
library(sf)
library(leaflet)

# FunciÃ³n de peticiÃ³n con reintentos
get_route <- function(src, dst, retries = 3, pause = 1) {
  for (i in seq_len(retries)) {
    attempt <- try(
      osrmRoute(src = src, dst = dst, overview = "full"),
      silent = TRUE
    )
    if (!inherits(attempt, "try-error")) return(attempt)
    Sys.sleep(pause)  # esperamos antes de reintentar
  }
  # Si sigue fallando, devolvemos un sf LINESTRING directo
  sf::st_linestring(matrix(c(src[1], dst[1], src[2], dst[2]), 
                           ncol = 2, byrow = TRUE)) %>%
    sf::st_sfc(crs = 4326) %>%
    sf::st_sf() 
}

# Prepara coords y orden
route_coords <- coords_df[match(best_path_names, coords_df$city), ]

# Construye la lista de segmentos con reintentos
route_segments <- lapply(seq_len(nrow(route_coords) - 1), function(i) {
  src <- as.numeric(route_coords[i,   c("lon","lat")])
  dst <- as.numeric(route_coords[i+1, c("lon","lat")])
  get_route(src, dst)
})

# Une todo en un solo sf
routes_sf <- do.call(rbind, route_segments)

# Dibuja en leaflet
leaflet() %>%
  addTiles() %>%
  addPolylines(data    = routes_sf,
               color   = "darkred",
               weight  = 4,
               opacity = 0.8) %>%
  addCircleMarkers(data       = route_coords,
                   ~lon, ~lat,
                   radius     = 5,
                   color      = "white",
                   fillColor  = "blue",
                   fillOpacity= 0.9,
                   label      = ~city) %>%
  setView(lng = mean(route_coords$lon),
          lat = mean(route_coords$lat),
          zoom = 6)

```

```{r}
# 1. Instala y carga
install.packages("leaflet")
library(leaflet)

# 2. Usa el mismo coords_df en orden de ruta
route_coords <- coords_df[match(best_path_names, coords_df$city), ]

# 3. Crea el mapa
leaflet(route_coords) %>%
  addTiles() %>%
  addPolylines(~lon, ~lat, color = "red", weight = 3, opacity = 0.7,
               label = best_path_names) %>%
  addCircleMarkers(~lon, ~lat, radius = 5,
                   color = "blue", fill = TRUE,
                   label = ~city)

```

```{r}
library(shiny)
library(leaflet)


route_coords <- coords_df[match(best_path_names, coords_df$city), ]

ui <- fluidPage(
  titlePanel("Hormiguita ACO en movimiento"),
  leafletOutput("map", height = 600)
)

server <- function(input, output, session) {
  # 1) Mapa base con marcadores estÃ¡ticos
  output$map <- renderLeaflet({
    leaflet(route_coords) %>%
      addTiles() %>%
      addCircleMarkers(
        ~lon, ~lat, label = ~city,
        radius = 5, color = "navy", fillOpacity = 0.8
      )
  })
  
  proxy <- leafletProxy("map")
  idx <- reactiveVal(1)
  
  observe({
    invalidateLater(800, session)
    i <- idx()
    sub <- route_coords[1:i, ]
    
    # 2) Borramos cualquier polilÃ­nea anterior
    proxy %>% clearShapes()
    
    # 3) Si tenemos al menos 2 puntos, dibujamos la ruta
    if (nrow(sub) > 1) {
      proxy %>% addPolylines(
        lng   = sub$lon,
        lat   = sub$lat,
        color = "red",
        weight= 3,
        layerId = "routeLine"
      )
    }
    
    # 4) Movemos el marcador â€œhormiguitaâ€
    proxy %>%
      removeMarker("movingMarker") %>%
      addCircleMarkers(
        lng     = sub$lon[i],
        lat     = sub$lat[i],
        layerId = "movingMarker",
        radius  = 8,
        color   = "orange",
        fillOpacity = 1
      )
    
    # 5) Incrementamos (o reiniciamos) el Ã­ndice
    idx(if (i < nrow(route_coords)) i + 1 else 1)
  })
}

shinyApp(ui, server)


```

```{r}
# 1. Instala y carga

library(leaflet)

# 2. Usa el mismo coords_df en orden de ruta
route_coords <- coords_df[match(best_path_names, coords_df$city), ]

# 3. Crea el mapa
leaflet(route_coords) %>%
  addTiles() %>%
  addPolylines(~lon, ~lat, color = "red", weight = 3, opacity = 0.7,
               label = best_path_names) %>%
  addCircleMarkers(~lon, ~lat, radius = 5,
                   color = "blue", fill = TRUE,
                   label = ~city)

```
